---
description: Riverpod state management for Flutter - 2025 version knowledge
globs: lib/**/*.dart, pubspec.yaml
---
# Riverpod 2.6+ Flutter Integration

## 基本的なセットアップ

Riverpodは、Flutterアプリケーションでリアクティブな状態管理を行うためのフレームワークです。最新バージョン（2.6+）では、コード生成機能が強化され、より簡潔に状態管理を実装できるようになっています。

### 依存関係のインストール

```yaml
dependencies:
  flutter:
    sdk: flutter
  flutter_riverpod: ^2.6.1
  riverpod_annotation: ^2.6.1

dev_dependencies:
  build_runner:
  custom_lint:
  riverpod_generator: ^2.6.5
  riverpod_lint: ^2.6.5
```

### アプリケーションのセットアップ

```dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

void main() {
  runApp(
    // アプリ全体をProviderScopeでラップして、Riverpodの状態管理を有効にする
    ProviderScope(
      child: MyApp(),
    ),
  );
}

// ConsumerWidgetを継承してRiverpodの状態を利用する
class MyApp extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return MaterialApp(
      // アプリケーションの設定...
    );
  }
}
```

## コード生成の活用

Riverpod 2.0以降では、`@riverpod`アノテーションを使用してプロバイダーを自動生成できます。

### コード生成の有効化

コード生成を使用するには、以下のコマンドを実行します：

```
dart run build_runner watch
```

### プロバイダーの定義

以下は各種プロバイダーの従来の書き方と、コード生成を使った新しい書き方の比較です：

#### Provider

**従来の書き方**:
```dart
final counterProvider = Provider<int>((ref) => 0);
```

**コード生成を使用した書き方**:
```dart
import 'package:riverpod_annotation/riverpod_annotation.dart';
part 'counter.g.dart';

@riverpod
int counter(CounterRef ref) => 0;
```

#### FutureProvider

**従来の書き方**:
```dart
final userProvider = FutureProvider<User>((ref) async {
  return fetchUser();
});
```

**コード生成を使用した書き方**:
```dart
@riverpod
Future<User> user(UserRef ref) async {
  return fetchUser();
}
```

#### StateNotifier/NotifierProvider

**従来の書き方**:
```dart
class CounterNotifier extends StateNotifier<int> {
  CounterNotifier() : super(0);
  
  void increment() => state++;
}

final counterProvider = StateNotifierProvider<CounterNotifier, int>((ref) {
  return CounterNotifier();
});
```

**コード生成を使用した書き方**:
```dart
@riverpod
class Counter extends _$Counter {
  @override
  int build() => 0;
  
  void increment() => state++;
}
```

### 自動破棄（AutoDispose）とファミリー（Family）機能

コード生成を使用する場合の自動破棄とファミリー機能の実装方法：

**AutoDispose**:
```dart
@Riverpod(keepAlive: false)
int counter(CounterRef ref) => 0;
```

**Family（パラメーター付きプロバイダー）**:
```dart
@riverpod
Future<User> user(UserRef ref, {required int userId}) async {
  final response = await httpClient.get('api/users/$userId');
  return User.fromJson(response.data);
}
```

## ウィジェットでの状態の使用

```dart
class CounterWidget extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // プロバイダーの状態を監視
    final counter = ref.watch(counterProvider);
    
    // 非同期プロバイダーの場合
    final asyncValue = ref.watch(userProvider);
    
    return asyncValue.when(
      data: (user) => Text('Hello, ${user.name}'),
      loading: () => CircularProgressIndicator(),
      error: (error, stack) => Text('Error: $error'),
    );
  }
}
```

## 状態の更新

```dart
class CounterPage extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return ElevatedButton(
      onPressed: () {
        // Notifierの場合
        ref.read(counterProvider.notifier).increment();
      },
      child: Text('Increment'),
    );
  }
}
```

## プロバイダーの組み合わせ

```dart
@riverpod
int doubledCounter(DoubledCounterRef ref) {
  final count = ref.watch(counterProvider);
  return count * 2;
}
```

## テスト対応

Riverpodはテスト可能性を重視しています。テストでは`ProviderContainer`を使用してプロバイダーをオーバーライドできます：

```dart
test('counter increments', () {
  final container = ProviderContainer(
    overrides: [
      // テスト用のモックデータを提供
      userProvider.overrideWith((ref) => Future.value(mockUser)),
    ],
  );
  
  expect(container.read(counterProvider), 0);
  container.read(counterProvider.notifier).increment();
  expect(container.read(counterProvider), 1);
});
```

## デバッグとロギング

Riverpodでは状態変更のログを取ることができます：

```dart
void main() {
  runApp(
    ProviderScope(
      observers: [Logger()],
      child: MyApp(),
    ),
  );
}

class Logger extends ProviderObserver {
  @override
  void didUpdateProvider(
    ProviderBase provider,
    Object? previousValue,
    Object? newValue,
    ProviderContainer container,
  ) {
    print('${provider.name ?? provider.runtimeType}: $newValue');
  }
} 
